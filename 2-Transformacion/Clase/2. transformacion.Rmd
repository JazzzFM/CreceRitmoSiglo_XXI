---
title: "Transformación de datos"
author: "Emilio Morones"
date: "5/4/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Prerequisitos

```{r}
library(nycflights13)
library(tidyverse)
```

Para explorar las funciones principales del paquete `dplyr` utilizaremos la base de datos `flights` 

```{r}
flights
```

Existen diferentes tipos de variables:

* int números enteros
* dbl números reales
* chr texto
* dttm fecha - hora
* lgl lógico
* fctr factor, variables categóricas
* date fecha


## Funciones básicas de `dplyr`

* filter() elige observaciones por sus valores
* arrange() reordena los renglones
* select() selecciona variables
* mutate() genera nuevas variables, generalmente son funciones de variables existentes
* summarise() colapsa muchos valores para tener un resumen

Estas funciones se pueden utilizar en conjunto con la función group_by()

Argumentos:

1. data.frame
2. Instrucciones que hacer con los datos

Resultados:

Un nuevo data.frame
  
  
## Filtrar renglones con filter()

```{r}
filter(flights, month == 1, day == 1)
```

Operadores comparativos: `>` (mayor a),`>=` (mayor o igual a),`<` (menor a),`<=` (menor o igual a),`!=` (diferente),`==` (igual)

Cuidados:

```{r}
sqrt(2) ^ 2 == 2
1 / 49 * 49 == 1
```

Utilizar función near()

```{r}
near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)
```

### Operadores lógicos

![x es el círculo de la izquierda, y es el de la derecha y la zona sombreada es lo que representa la operación](operadores.png)

```{r, eval = F}
filter(flights, month == 11 | month == 12)
```

```{r, eval = F}
filter(flights, month %in% c(11,12))
```

Algunas veces filtros complicados se pueden simplificar con la ley De Morgan:

* `!(x & y)` es lo mismo a `!x | !y`
* `!(x | y)` es lo mismo a `!x & !y`

Por ejemplo:

```{r, eval = F}
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
```

### Valores faltantes

Algo que podría hacer a `R` un tanto mañoso es el trato de los valores faltantes. Casi cualquier operación que involucre valores faltantes también será desconocido.

```{r}
NA > 1
1 == NA
NA + 1
NA / 1
NA == NA
```

```{r}
is.na(NA)
```

```{r}
bd <-  tibble(x = c(1:3, NA))
filter(bd, x > 2)
filter(bd, x > 2 | is.na(x))
```

### Ejercicios

1. Encuentra todos los vuelos que:
* Que tuviern un retraso de llegada de 2 horas o más
* Volaron a Houston (IAH o HOU)
* fueron operados por United, American, o Delta
* Salieron en Julio, Agosto y Septiembre
* LLegaron más de dos horas tarde pero no salieron tarde
* Salieron al menos una hora tarde pero recuperaron 30 minutos de vuelo
* Salieron de la media noche a las 6am (incluyéndo)

2. Otra función muy útil de `dplyr` es `between()`. ¿Qué hace? ¿Podrías utilizarlo para simplificar el código  para responder las preguntas anteriores?

3. ¿Cuántos vuelos no tienen información en la variable `dep_time`? ¿Qué otras variables faltan? ¿Qué podrían representar estos renglones?

4. ¿Por qué `NA ^ 0`, `NA | TRUE`, `FALSE & NA` no son valores faltantes? ¿Podrías descubrir una regla general? (NA * 0 tiene truco)

## Ordenar renglones con arrange()


```{r}
arrange(flights, year, month, day)
```

Cada columna adicional que proveas se utiliza para romper empates en los valores de las columnas procedentes

```{r}
arrange(flights, desc(dep_delay))
```

### Ejercicios

Los valores faltantes siempre se acomodan al final
```{r}
bd <- tibble(x = c(5, 7, NA, 3, 5, 2, NA))
arrange(bd, x)
arrange(bd, desc(x))
```

1. ¿Cómo usarías la función `arrange()` para ordenar todos los valores empezando por los NA? (Tip: utiliza `is.na()`)

2. Ordena la base de datos `flights` para encontrar los vuelos con mayor retraso. Encuentra los vuelos que salieron más temprano

3. Ordena `flights` para encontrar los vuelos más rápidos

4. ¿Qué vuelos viajaron más lejos. ¿Cuáles viajaron la menor distancia?

## Seleccionar columnas con `select()`

Es común que manejemos datos con cientos de variables. Seleccionar las variables que realmente interesan es la tarea de select

```{r}
select(flights, year, month, day)
select(flights, year:day)
select(flights, -(year:day))
```

Hay más funciones que se pueden utilizar dentro de selet como:

* `starts_with()` variables que empiezan con cierto patrón
* `ends_with()` variables que terminan con cierto patrón
* `contains()` variables que contienen cierto patrón
* `matches()` variables que coinciden con expresiones regulares (más adelante profundizaré)
* `num_range("x", 1:3)` que coincida con `x1`, `x2` y `x3`

Revisa ?select para mayor detalle

También es posible renombrar variables al seleccionarlas. Esto es poco útil ya el resultado final contendría sólo las variables seleccionadas. Si el objetivo es renombrar variables utiliza `rename()`

```{r}
select(flights, tail_num = tailnum)
rename(flights, tail_num = tailnum)
```

Podrías utilizar la función `everything()` para cambiar el orden de las variables

```{r}
select(flights, time_hour, air_time, everything())
```

Otra forma de cambiar el orden de las columnas es con `relocate()` 
 
```{r}
relocate(flights, time_hour, dep_time, .before = year)
```

Revisa `?relocate` para mayor detalle
  
### Ejercicios

1. ¿Cuántas formas se te ocurren para seleccionar las variables `dep_time`, `dep_delay`, `arr_time` y `arr_delay` de `flights`?

2. ¿Qué pasa si incluyes el nombre de una variable múltiples veces en un sólo `select()`?

3. ¿Qué hace la función `any_of()`? ¿Cómo podría ayudar al tener el siguiente vector?

```{r, eval = F}
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
```

4. ¿Te sorpende el resultado del siguiente código?

```{r}
select(flights, contains("TIME"))
```

¿Cuál es el tratamiento de las funciones adicionales con las mayúsculas por defecto? ¿Cómo podrías cambiarlo?

## Agrega nuevas variables con `mutate()`

Cuando creamos nuevas columnas con `mutate()` siempre se agregarán al final de la base de datos. Por esto es buena idea seleccionar primero las columnas más relevantes para poder visualizar los resultados del `mutate()`

```{r}
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)

mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)
```

Nota que puedes hacer referencia a las columnas que acabas de crear

```{r}
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

Si sólo quieres mantener las columnas que acabas de transformar utiliza `transmute()`

```{r}
transmute(flights,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

### Funciones útiles para crear variables

La propiedad fundamental de las funciones es que debe estar vecotrizadas, es decir, tomar valores de un vector como entrada y como salida debe ser otro vector del mismo tamaño. Hay una gama muy grande de funciones que pueden ser utilizadas pero entre las más comunes son las siguientes:

* operaciones aritméticas: `+`, `-`, `*`, `/`, `^` . También son útiles al usarlas en conjunto con funciones agregadoras por ejemplo `x / sum(x)` para calcular la proporción del total, `y - mean(y)` calcula la diferencia de cada valor de la variable `y` con respecto a la media de la variable `y`

* Operaciones modulares: `%/%` (el número entero al hacer una división) y `%%` el residuo.

```{r}
transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)
```


* Logaritmos: `log()`, `log2()`, `log10()`. Son útiles para tratar con datos que tienen magnitudes muy diferentes. Convierten una relación multiplicativa en aditiva (esto lo clarificaremos en la sección de modelaje). `log2()` es recomendable porque es fácil de interpretar: una diferencia de 1 en la escla logarítmica corresponde al doble en la escala original, una diferencia de -1 corresponde a la mitad en la escala original.

* Compensaciones: `lead()` y `lag()` (ej. `x - lag(x)` diferencias entre valores) (ej2. `x != lag(x)` enconotrar los valores cuando cambian). 

```{r}
(x <- 1:10)
lag(x)
lead(x)
```

* Operaciones cumulativas: `cumsum()`, `cumprod()`, `cummin()`, `cummax()`, `cummean()`

```{r}
cumsum(x)
cummean(x)
```

* Comparaciones lógicas: `<`, `<=`, `>`, `!=`, `==`

* Ranking: investiga qué hacen las siguientes funciones `min_rank()`, `dense_rank()`, `percent_rank()`, `cume_dist()`, `ntile()`

```{r}
y <- c(1, 2, 2, NA, 3, 4)
min_rank(y)
min_rank(desc(y))
row_number(y)
dense_rank(y)
percent_rank(y)
cume_dist(y)
```

### Ejercicios

1. `dep_time` y `sched_dep_time` son fáciles de ver pero difíciles de computar porque no son números continuos. Conviértelos a una representación más amigable de minutos desde la media noche.

2. Compara `air_time` con `arr_time - dep_time`. ¿Qué esperas ver? ¿Qué ves en realidad? ¿Qué debes cambiar?

3. Compara `dep_time`, `sched_dep_time` y `dep_delay`. ¿Cómo esperas que esos 3 números se relacionen?

4. Encuentra los vuelos más retrasados utilizando alguna función de ranking. ¿Cómo quieres manejar los empates? Lee cuidadosamente la documentación `min_rank()`

5. ¿Cuál es el resultado de `1:3 + 1:10`. ¿Por qué?

6. ¿Qué funciones trigonométricas provee R?

##  Resúmenes por grupos utilizando `summarise()`

El último verbo clave es `summarise()`. Colapsa una marco de datos en un solo renglón:

```{r}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

Más adelante ahondaremos en el parámetro `na.rm = TRUE`

`summarise()` no es tan útil a menos que se utilice en conjunto con `group_by()`. Esto hace que la unidad de análisis cambie a los grupos que selecciones. Por ejemplo:

```{r}
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))
```

Estas últimas herramientas son las que utilizarás más comúnmente cuando trabajes con `dplyr`. Antes de continuar quisiera hacer un paréntesis acerca del "pipe".

### Combinar múltiples operacioines con el pipe

Imagina que queremos explorar las relaciones entre la distancia y el retraso promedio para cada destino. Utilizando el conocimiento que ahora tienes de `dplyr` y `ggplot`:

```{r}
by_dest <- group_by(flights, dest)
delay <- summarise(by_dest,
  count = n(),
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)

delay <- filter(delay, count > 20, dest != "HNL")

ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
  geom_point(aes(size = count), alpha = 1/3) +
  geom_smooth(se = FALSE)
```

Los pasos que seguí para preparar los datos fueron los siguientes:

1. Agrupar los vuelos por destino

2. Resumir y computar la distancia, el retraso promedio y el número de vuelos.

3. Filtrar para remover puntos ruidosos y el aeropuerto de Honolulu, que está casi al doble de distancia que el aeropuerto más cercano a éste.

Es frustrante esta estrategia porque tenemos que guardar cada paso intermedio en un objeto. Nombrar objetos es difícil, así que esto alenta tu análisis.

Una forma diferente de resolverlo es utilizando el pipe, `%>%`:

```{r}
delays <- flights %>% 
  group_by(dest) %>% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>% 
  filter(count > 20, dest != "HNL")
```

Es much más fácil de leer: agrupas, luego resumes, luego filtras.

### Valores faltantes

¿Qué pasa si no escribimos el argumento `na.rm` en el ejemplo anterior?

```{r}
flights %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay))
```

Obtenemos muchos valores faltantes. Esto es porque las funciones de agregación obedecen la regla usual de los valores faltantes: si hay algún valor faltante como entrada, el resultado también faltará. Afortunadamente todas las funciones de agregación tienen el argumento `na.rm` que remueve los valores faltantes previamente a la computación

```{r}
flights %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay, na.rm = TRUE))
```

En este caso, donde hay valores faltantes representa a los vuelos cancelados. También podríamos resolver el problema al remover los vuelos cancelados y guardar este conjunto de datos para reutilizarlo después

```{r}
not_cancelled <- flights %>% 
  filter(!is.na(dep_delay), !is.na(arr_delay))

not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay))
```

### Conteos

Una buena práctica cuando realizas cualquier aggregación es incluir un conteo de observaciones (`n()`) or grupo o un conteo de valores no faltantes (`sum(!is.na(x))`). De esta forma puedes revisar que no estes haciendo conclusiones basadas en muy pocos datos. Por ejemplo, veamos los aviones (identificados por `tailnum`) que tienen el  promedio de retraso más alto:

```{r}
delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay)
  )

ggplot(data = delays, mapping = aes(x = delay)) + 
  geom_freqpoly(binwidth = 10)
```

Hay aviones que tienen un promedio de retraso de 300 minutos. Podemos ver mayor detalle si hacemos una gráfica de dispersión del número de vuelos vs. retraso promedio por avión.

```{r}
delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(data = delays, mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)
```

Por lo general, cuando graficas el promedio (o cualquier otro resumen estadístico) vs el tamaño del grupo, verás que la variación decrece mientras el tamaño incrementa.

Usualmente es útil filtrar los grupos con el menor número de observaciones para poder ver mejor el patrón y menos la variación extrema de los grupos pequeños.

```{r}
delays %>% 
  filter(n > 25) %>% 
  ggplot(mapping = aes(x = n, y = delay)) + 
    geom_point(alpha = 1/10)
```

### Funciones de resúmenes útiles

* Medidas de localización: `mean()`, `median()`. La media es la suma dividida por el total de observaciones. La mediana es el valor en donde el 50% de los valores estan por encima y por debajo.

A veces es útil combinar las agregaciones con filtros lógicos (posteriormente los veremos)

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    avg_delay1 = mean(arr_delay),
    avg_delay2 = mean(arr_delay[arr_delay > 0]) # the average positive delay
  )
```

* Medidas de dispersión: `sd()`, `IQR()`, `mad()`. La desviación estandard es la medida estandard de dispersión. El rango interquartílico y la mediana absoluta de desviación son equivalentes robustos, que podrían ser más útiles cuando tengas más valores atípicos.

¿Por qué la distancia a ciertos destinos son más variables que otros?

```{r}
not_cancelled %>% 
  group_by(dest) %>% 
  summarise(distance_sd = sd(distance)) %>% 
  arrange(desc(distance_sd))
```

* Medidas de rango: `min()`, `quantile(x,0.25)`, `max()`. Los cuantiles generaliza el concepto de mediana. Por ejemplo, el cuantil 0.25 encontrará el valor `x` que es mayor al 25% de los valores y menor al 75% restante.

¿Cuándo es que el primer vuelo y el último salen todos los días?

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    first = min(dep_time),
    last = max(dep_time)
  )
```

* Medias de posición: `first()`, `nth(x, 2)`, `last(x)`. Esto funciona de forma muy similar a `x[1]`, `x[2]`, y  `x[length(x)]`.

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    first_dep = first(dep_time), 
    last_dep = last(dep_time)
  )
```

También es posible lograr la misma tarea pero con todas las observaciones utilizando la función `filter()`

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  mutate(r = min_rank(desc(dep_time))) %>% 
  filter(r %in% range(r))
```

* Conteos: Hemos visto que utilizar `n()`, que no recibe argumentos, regresa el tamaño del grupo actual. Para contar el número de datos sin valores faltantes utilizamos, `sum(!is.na(x))`. Para contar el número de categorías únicas podemos utilizar `n_distinct()`

```{r}
not_cancelled %>% 
  group_by(dest) %>% 
  summarise(carriers = n_distinct(carrier)) %>% 
  arrange(desc(carriers))
```

Los conteos son tan útiles que dplyr ofrece una función en particular

```{r}
not_cancelled %>% 
  count(dest)
```

Opcionalmente puedes proveer una variable de peso. Por ejemplo, podemos sumar el total de millas que voló un avión:

```{r}
not_cancelled %>% 
  count(tailnum, wt = distance)
```

* Conteos y proporciones de valores lógicos: `sum(x>10)`, `mean(y == 0)`. Cuando se utilizan como funciones numéricas, TRUE se convierte en 1 y FALSE en 0. Esto le da una dimensión diferente a `sum()` (da el número de TRUE en x) y `mean()`(da la proporción)

¿Cuántos vuelos salieron antes de las 5am por día?

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(n_early = sum(dep_time < 500))
```

¿Qué proporción de vuelos se retrasaron por más de una hora por día?

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(hour_prop = mean(arr_delay > 60))
```

### Agrupando por múltiples variables

Cada vez que realizas un resumen se remueve un nivel de las variables de grupos

```{r}
daily <- group_by(flights, year, month, day)
(per_day   <- summarise(daily, flights = n()))
(per_month <- summarise(per_day, flights = sum(flights)))
(per_year  <- summarise(per_month, flights = sum(flights)))
```

En este caso funciona bien sumar consecutivamente y da el resultado correcto. Hacer esta progresión no es lo mismo cuando queremos calcular promedios, medianas, varianzas, etc. Tendríamos que penar en los pesos con medias y varianzas y no es posible realizarlo con la mediana. En otras palabras, la suma de grupos es efectivamente la suma de todo,, pero la mediana de de las medianas de un grupo no es la mediana global.

Si quieres desagrupar sólo utiliza la función `ungroup()`

```{r}
daily %>% 
  ungroup() %>%             
  summarise(flights = n())  
```

### Ejercicios

1. Intenta obtener el mismo resultado que dan los siguientes códigos `not_cncelled %>% count(dest)` y `not_cancelled %>% count(tailnum, wt = distnace)` (sin utilizar la función `count()`)

2. La definición de vuels cancelados es (`is.na(dep_delay) | is.na(arr_delay)`) no es óptima, ligeramente. ¿Por qué? ¿Cuál es la columna más importante?

3. Revisa el número de vuelos cancelados por día. ¿Existe algún patrón? ¿Está la proporción de vuelos cancelados relacionado con el retraso promedio?

4. ¿Qué aerolínea tiene los peores retrasos? Reto: podrías descubrir el efecto de malos aeropuertos vs. malas aerolíneas? ¿Por qué o por qué no? (Tip: peinsa en  `flights %>% group_by(carrier, dest) %>% summarise(n())`)

5. ¿Qué hace el argumento `sort` en la función `count()`?

## Mutates y filters agrupados

* Encontrar los peores miembros de un grupo

```{r}
flights_sml %>% 
  group_by(year, month, day) %>%
  filter(rank(desc(arr_delay)) < 10)
```

* Encontrar grupos que son mayores a un umbral

```{r}
popular_dests <- flights %>% 
  group_by(dest) %>% 
  filter(n() > 365)
popular_dests
```

* Computar las métricas por grupo

```{r}
popular_dests %>% 
  filter(arr_delay > 0) %>% 
  mutate(prop_delay = arr_delay / sum(arr_delay)) %>% 
  select(year:day, dest, arr_delay, prop_delay)
```

Funciones que trabajan naturalmente con mutates y filters agrupados se conocen como funciones ventana. Lee la siguiente documentación `vignette("window-functions")`

### Ejercicios

1. ¿Qué avión (`tailnum`) tiene el peor record de llegadas a tiempo? (proporción de vuelos no retrasados o cancelados o media del retraso de llegada)

2. ¿En qué hora deberías tomar un vuelo para evitar retrasos lo más posible?

3. Para cada destino, calcula l total de minutos retrasados. Para cada vuelo, calcula la proporción del total de retraso para su destino.

4. Los retrasos normalmente estan correlacionados en el tiempo, es decir, a pesar de que el problema que causó el retraso inicial se resolvió, los vuelos posteriores se retrasan para permitir que los vuelos retrasados salgan. Utiliza `lag()`, explora cómo el retraso de un vuelo está relacionado al retraso del vuelo que seguía.

5. Ve cada destino. Podrías encontrar vuelos que son sospechosamente rápidos? (es decir, vuelos que representan datos erróneos). Calcula el tiempo en aire de un vuelo relativo al vuelo más corto a ese destino. ¿Qué vuelos fueron más retrasados en el aire?

6. Encuentra todos los destinos que existen vuelos de al menos dos compañías. Usa esa información para rankearlos.

7. Para cada avión, cuenta el número de vuelos  anteriores al primer retraso mayor a 1 hora.